import { systemShare } from '@kit.ShareKit';
import { uniformTypeDescriptor } from '@kit.ArkData';
import { image } from '@kit.ImageKit';
import { componentSnapshot } from '@kit.ArkUI';
import { common } from '@kit.AbilityKit';
import prompt from '@ohos.prompt';
import fs from '@ohos.file.fs';
import { PoopRecord } from '../model/RecordModel';

// å®šä¹‰é€‰é¡¹æ¥å£
interface OptionItem {
  value: string;
  label: string;
}

// å®šä¹‰åˆ†äº«é€‰é¡¹æ¥å£
interface ShareOptions {
  previewMode: systemShare.SharePreviewMode;
  selectionMode: systemShare.SelectionMode;
}

/**
 * åˆ†äº«å·¥å…·ç±»
 * æä¾›æ–‡æœ¬åˆ†äº«ã€å›¾ç‰‡åˆ†äº«ç­‰åŠŸèƒ½
 */
export class ShareUtils {
  
  static async shareText(text: string, title?: string, context?: common.UIAbilityContext): Promise<void> {
    try {
      const sharedData = new systemShare.SharedData({
        utd: uniformTypeDescriptor.UniformDataType.PLAIN_TEXT,
        content: text
      });
      
      const controller = new systemShare.ShareController(sharedData);
      
      const targetContext = context || ShareUtils.getContext();
      await controller.show(targetContext, {
        previewMode: systemShare.SharePreviewMode.DEFAULT,
        selectionMode: systemShare.SelectionMode.SINGLE
      });
      
      prompt.showToast({
        message: 'åˆ†äº«æˆåŠŸ',
        duration: 2000
      });
    } catch (error) {
      console.error('åˆ†äº«æ–‡æœ¬å¤±è´¥:', error);
      prompt.showToast({
        message: 'åˆ†äº«å¤±è´¥',
        duration: 2000
      });
    }
  }

  static async shareImage(imageUri: string, title?: string, context?: common.UIAbilityContext): Promise<void> {
    try {
      const sharedData = new systemShare.SharedData({
        utd: uniformTypeDescriptor.UniformDataType.IMAGE,
        content: imageUri
      });
      
      const controller = new systemShare.ShareController(sharedData);
      
      const targetContext = context || ShareUtils.getContext();
      await controller.show(targetContext, {
        previewMode: systemShare.SharePreviewMode.DEFAULT,
        selectionMode: systemShare.SelectionMode.SINGLE
      });
      
      prompt.showToast({
        message: 'åˆ†äº«æˆåŠŸ',
        duration: 2000
      });
    } catch (error) {
      console.error('åˆ†äº«å›¾ç‰‡å¤±è´¥:', error);
      prompt.showToast({
        message: 'åˆ†äº«å¤±è´¥',
        duration: 2000
      });
    }
  }

  static async shareComponentSnapshot(componentId: string, title?: string, context?: common.UIAbilityContext): Promise<void> {
    try {
      // è·å–ç»„ä»¶æˆªå›¾
      const pixelMap = await componentSnapshot.get(componentId);
      const imageUri = await ShareUtils.savePixelMapToFile(pixelMap);
      
      const sharedData = new systemShare.SharedData({
        utd: uniformTypeDescriptor.UniformDataType.IMAGE,
        content: imageUri
      });
      
      const controller = new systemShare.ShareController(sharedData);
      
      const targetContext = context || ShareUtils.getContext();
      await controller.show(targetContext, {
        previewMode: systemShare.SharePreviewMode.DEFAULT,
        selectionMode: systemShare.SelectionMode.SINGLE
      });
      
      prompt.showToast({
        message: 'åˆ†äº«æˆåŠŸ',
        duration: 2000
      });
    } catch (error) {
      console.error('åˆ†äº«ç»„ä»¶æˆªå›¾å¤±è´¥:', error);
      prompt.showToast({
        message: 'åˆ†äº«å¤±è´¥',
        duration: 2000
      });
    }
  }

  static async shareRecord(record: PoopRecord, componentId?: string, context?: common.UIAbilityContext): Promise<void> {
    try {
      const recordText = ShareUtils.formatRecordText(record);
      
      const sharedData = new systemShare.SharedData({
        utd: uniformTypeDescriptor.UniformDataType.PLAIN_TEXT,
        content: recordText
      });
      
      const controller = new systemShare.ShareController(sharedData);
      
      await controller.show(ShareUtils.getContext(), {
        previewMode: systemShare.SharePreviewMode.DEFAULT,
        selectionMode: systemShare.SelectionMode.SINGLE
      });
      
      prompt.showToast({
        message: 'åˆ†äº«æˆåŠŸ',
        duration: 2000
      });
    } catch (error) {
      console.error('åˆ†äº«è®°å½•å¤±è´¥:', error);
      prompt.showToast({
        message: 'åˆ†äº«å¤±è´¥',
        duration: 2000
      });
    }
  }

  private static formatRecordText(record: PoopRecord): string {
    return `æˆ‘çš„ä¾¿ä¾¿è®°å½• ğŸ“Š\n` +
      `æ—¶é—´: ${ShareUtils.formatDate(record.date)} ${record.time}\n` +
      `å¿ƒæƒ…: ${ShareUtils.getMoodLabel(record.mood)}\n` +
      `ç‰¹å¾: ${ShareUtils.getColorLabel(record.color)} Â· ${ShareUtils.getShapeLabel(record.shape)} Â· ${ShareUtils.getSizeLabel(record.size)}\n` +
      `æ¥è‡ªä¾¿ä¾¿è®°å½•å°åŠ©æ‰‹ ğŸ’©`;
  }

  private static getContext(): common.UIAbilityContext {
    // è·å–å½“å‰åº”ç”¨ä¸Šä¸‹æ–‡
    return getContext() as common.UIAbilityContext;
  }

  private static async savePixelMapToFile(pixelMap: image.PixelMap): Promise<string> {
    try {
      // åˆ›å»ºå›¾ç‰‡æ‰“åŒ…å™¨
      const imagePackerApi = image.createImagePacker();
      const packOpts: image.PackingOption = {
        format: 'image/jpeg',
        quality: 90
      };
      
      // å°†PixelMapæ‰“åŒ…ä¸ºå›¾ç‰‡æ•°æ®
      const imageData = await imagePackerApi.packing(pixelMap, packOpts);
      
      // è·å–åº”ç”¨ç¼“å­˜ç›®å½•
      const context = ShareUtils.getContext();
      const cacheDir = context.cacheDir;
      const fileName = `share_image_${Date.now()}.jpg`;
      const filePath = `${cacheDir}/${fileName}`;
      
      // å°†å›¾ç‰‡æ•°æ®å†™å…¥æ–‡ä»¶
      const file = fs.openSync(filePath, fs.OpenMode.CREATE | fs.OpenMode.WRITE_ONLY);
      fs.writeSync(file.fd, imageData);
      fs.closeSync(file);
      
      // è¿”å›æ–‡ä»¶URI
      return `file://${filePath}`;
    } catch (err) {
      console.error('ä¿å­˜å›¾ç‰‡æ–‡ä»¶å¤±è´¥:', err);
      throw new Error(`ä¿å­˜å›¾ç‰‡æ–‡ä»¶å¤±è´¥: ${err}`);
    }
  }

  // è¾…åŠ©æ–¹æ³•
  private static formatDate(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  private static getMoodLabel(mood: string): string {
    const MOOD_OPTIONS: OptionItem[] = [
      { value: 'happy', label: 'ğŸ˜Š å¼€å¿ƒ' },
      { value: 'normal', label: 'ğŸ˜ ä¸€èˆ¬' },
      { value: 'tired', label: 'ğŸ˜´ ç–²æƒ«' },
      { value: 'uncomfortable', label: 'ğŸ˜£ ä¸é€‚' }
    ];
    const option = MOOD_OPTIONS.find(opt => opt.value === mood);
    return option ? option.label : mood;
  }

  private static getColorLabel(color: string): string {
    const COLOR_OPTIONS: OptionItem[] = [
      { value: 'brown', label: 'æ£•è‰²' },
      { value: 'yellow', label: 'é»„è‰²' },
      { value: 'green', label: 'ç»¿è‰²' },
      { value: 'black', label: 'é»‘è‰²' },
      { value: 'red', label: 'çº¢è‰²' }
    ];
    const option = COLOR_OPTIONS.find(opt => opt.value === color);
    return option ? option.label : color;
  }

  private static getShapeLabel(shape: string): string {
    const SHAPE_OPTIONS: OptionItem[] = [
      { value: 'normal', label: 'æ­£å¸¸' },
      { value: 'hard', label: 'ç¡¬å—' },
      { value: 'soft', label: 'è½¯ä¾¿' },
      { value: 'loose', label: 'ç¨€ä¾¿' },
      { value: 'watery', label: 'æ°´æ ·' }
    ];
    const option = SHAPE_OPTIONS.find(opt => opt.value === shape);
    return option ? option.label : shape;
  }

  private static getSizeLabel(size: string): string {
    const SIZE_OPTIONS: OptionItem[] = [
      { value: 'small', label: 'å°' },
      { value: 'medium', label: 'ä¸­' },
      { value: 'large', label: 'å¤§' }
    ];
    const option = SIZE_OPTIONS.find(opt => opt.value === size);
    return option ? option.label : size;
  }
}