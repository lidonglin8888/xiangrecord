import http from '@ohos.net.http';
import { PoopRecord } from '../model/RecordModel';
import { NetworkConfig } from '../config/NetworkConfig';
import { Logger } from '../utils/Logger';
import { UserManager } from '../model/UserModel';
import { HttpInterceptor } from './HttpInterceptor';
import type { RequestConfig } from './HttpInterceptor';

// APIå“åº”æ¥å£
export interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
  timestamp: string;
}

// åˆ†é¡µæ•°æ®æ¥å£
interface PageData<T> {
  records: T[];
  total: number;
  page: number;
  size: number;
}

// åˆ†é¡µå“åº”æ¥å£
interface PageResponse<T> {
  records: T[];
  total: number;
  page: number;
  size: number;
  success: boolean;
  message: string;
}

// æœç´¢å‚æ•°æ¥å£
interface SearchParams {
  color?: string;
  mood?: string;
  startTime?: string;
  endTime?: string;
  page?: number;
  size?: number;
}

// ç»Ÿè®¡å‚æ•°æ¥å£
interface CountParams {
  color?: string;
  mood?: string;
  startTime?: string;
  endTime?: string;
}

// åç«¯DTOæ¥å£ï¼ˆä¸åç«¯ä¿æŒä¸€è‡´ï¼‰
export interface PoopRecordDTO {
  id: number;
  recordTime: string; // ISOæ ¼å¼æ—¶é—´å­—ç¬¦ä¸²
  color: string;
  smell: string;
  moisture: string;
  shape: string;
  size: string;
  texture: string;
  mood: string;
  notes?: string;
  userId?: string; // ç”¨æˆ·ID
}

// HTTPè¯·æ±‚é€‰é¡¹æ¥å£
interface HttpRequestOptions {
  method: http.RequestMethod;
  header: Record<string, string>;
  connectTimeout: number;
  readTimeout: number;
  extraData?: string;
}

// APIæœåŠ¡ç±»
interface GeneratedTypeLiteralInterface_1 {
  records: PoopRecord[];
  total: number;
}

interface GeneratedTypeLiteralInterface_2 {
  records: PoopRecord[];
  total: number;
}

interface GeneratedTypeLiteralInterface_3 {
  records: PoopRecord[];
  total: number;
}

interface GeneratedTypeLiteralInterface_4 {
  records: PoopRecord[];
  total: number;
}

export class ApiService {
  // ä½¿ç”¨ç½‘ç»œé…ç½®æ–‡ä»¶ä¸­çš„è®¾ç½®
  private static readonly BASE_URL = NetworkConfig.getApiBaseUrl();
  private static readonly TIMEOUT = NetworkConfig.CONNECT_TIMEOUT;

  // åˆ›å»ºHTTPè¯·æ±‚
  private static createHttpRequest(): http.HttpRequest {
    return http.createHttp();
  }

  // é€šç”¨è¯·æ±‚æ–¹æ³•ï¼ˆä½¿ç”¨æ‹¦æˆªå™¨ï¼‰
  private static async request<T>(
    url: string,
    method: http.RequestMethod,
    data?: Object
  ): Promise<ApiResponse<T>> {
    try {
      Logger.api(`å‘èµ·è¯·æ±‚: ${method} ${url}`);
      if (data) {
        Logger.debug('API', 'è¯·æ±‚æ•°æ®:', JSON.stringify(data));
      }

      const config: RequestConfig = {
        url,
        method,
        data
      };

      const result = await HttpInterceptor.request<ApiResponse<T>>(config);
      Logger.api('è¯·æ±‚æˆåŠŸ');
      return result;
    } catch (error) {
      Logger.error('API', `è¯·æ±‚å¤±è´¥ - URL: ${url}`);
      Logger.error('API', 'é”™è¯¯è¯¦æƒ…:', error instanceof Error ? error.message : String(error));
      
      // æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯å’Œè§£å†³å»ºè®®
      if (error instanceof Error) {
        Logger.error('API', `é”™è¯¯æ¶ˆæ¯: ${error.message}`);
        
        if (error.message.includes('timeout') || error.message.includes('Timeout')) {
          Logger.error('API', 'ğŸ”¥ è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒæœåŠ¡å™¨çŠ¶æ€');
        } else if (error.message.includes('connect') || error.message.includes('Connection')) {
          Logger.error('API', 'ğŸ”¥ æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨åœ°å€å’Œç«¯å£');
          Logger.error('API', `å½“å‰æœåŠ¡å™¨åœ°å€: ${ApiService.BASE_URL}`);
        } else if (error.message.includes('network') || error.message.includes('Network')) {
          Logger.error('API', 'ğŸ”¥ ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
        } else if (error.message.includes('Tokenåˆ·æ–°å¤±è´¥') || error.message.includes('é‡æ–°ç™»å½•')) {
          Logger.error('API', 'ğŸ”¥ è®¤è¯å¤±è´¥ï¼Œéœ€è¦é‡æ–°ç™»å½•');
          // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘ç™»å‡ºé€»è¾‘
          UserManager.logout().catch((logoutError: Error) => {
            Logger.error('API', 'è‡ªåŠ¨ç™»å‡ºå¤±è´¥:', logoutError.message);
          });
        } else {
          Logger.error('API', 'ğŸ”¥ æœªçŸ¥é”™è¯¯ç±»å‹ï¼Œè¯·æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯');
        }
      }
      
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(errorMsg);
    }
  }

  // è½¬æ¢å‰ç«¯æ¨¡å‹åˆ°åç«¯DTO
  private static toDTO(record: PoopRecord): PoopRecordDTO {
    const timeParts = record.time.split(':');
    const hours = parseInt(timeParts[0]);
    const minutes = parseInt(timeParts[1]);
    const recordDateTime = new Date(record.date.getTime() + hours * 60 * 60 * 1000 + minutes * 60 * 1000);

    return {
      id: record.id,
      recordTime: recordDateTime.toISOString(),
      color: record.color,
      smell: record.smell,
      moisture: record.moisture,
      shape: record.shape,
      size: record.size,
      texture: record.texture,
      mood: record.mood,
      notes: record.notes,
      userId: record.userId // åŒ…å«ç”¨æˆ·ID
    };
  }

  // è½¬æ¢åç«¯DTOåˆ°å‰ç«¯æ¨¡å‹
  private static fromDTO(dto: PoopRecordDTO): PoopRecord {
    const recordTime = new Date(dto.recordTime);
    const hours = recordTime.getHours().toString().padStart(2, '0');
    const minutes = recordTime.getMinutes().toString().padStart(2, '0');

    return {
      id: dto.id,
      date: new Date(recordTime.getFullYear(), recordTime.getMonth(), recordTime.getDate()),
      time: `${hours}:${minutes}`,
      color: dto.color,
      smell: dto.smell,
      moisture: dto.moisture,
      shape: dto.shape,
      size: dto.size,
      texture: dto.texture,
      mood: dto.mood,
      notes: dto.notes,
      userId: dto.userId // åŒ…å«ç”¨æˆ·ID
    };
  }

  // åˆ›å»ºè®°å½•
  static async createRecord(record: PoopRecord): Promise<PoopRecord> {
    const dto = ApiService.toDTO(record);
    const response = await ApiService.request<PoopRecordDTO>(
      ApiService.BASE_URL,
      http.RequestMethod.POST,
      dto
    );
    return ApiService.fromDTO(response.data);
  }

  // è·å–å•ä¸ªè®°å½•
  static async getRecord(id: string): Promise<PoopRecord> {
    const response = await ApiService.request<PoopRecordDTO>(
      `${ApiService.BASE_URL}/${id}`,
      http.RequestMethod.GET
    );
    return ApiService.fromDTO(response.data);
  }

  // æ›´æ–°è®°å½•
  static async updateRecord(id: number, record: PoopRecord): Promise<PoopRecord> {
    const dto = ApiService.toDTO(record);
    const response = await ApiService.request<PoopRecordDTO>(
      `${ApiService.BASE_URL}/${id}`,
      http.RequestMethod.PUT,
      dto
    );
    return ApiService.fromDTO(response.data);
  }

  // åˆ é™¤è®°å½•
  static async deleteRecord(id: number): Promise<void> {
    await ApiService.request<void>(
      `${ApiService.BASE_URL}/${id}`,
      http.RequestMethod.DELETE
    );
  }

  // è·å–æ‰€æœ‰è®°å½•ï¼ˆåˆ†é¡µï¼‰
  static async getAllRecords(
    page: number = 1,
    size: number = 10,
    sortBy: string = 'recordTime',
    sortDir: string = 'desc'
  ): Promise<GeneratedTypeLiteralInterface_3> {
    let url = `${ApiService.BASE_URL}?page=${page}&size=${size}&sortBy=${sortBy}&sortDir=${sortDir}`;
    
    // åœ¨äº‘ç«¯æ¨¡å¼ä¸‹æ·»åŠ userIdå‚æ•°
    const currentUser = UserManager.getCurrentUser();
    if (currentUser) {
      url += `&userId=${encodeURIComponent(currentUser.id)}`;
    }
    
    const response = await ApiService.request<PageResponse<PoopRecordDTO>>(url, http.RequestMethod.GET);
    
    // æ·»åŠ ç©ºå€¼æ£€æŸ¥
    if (!response.data || !response.data.records) {
      Logger.error('API', 'APIå“åº”æ•°æ®ä¸ºç©ºæˆ–ç¼ºå°‘recordså­—æ®µ');
      return {
        records: [],
        total: 0
      };
    }
    
    return {
      records: response.data.records.map((dto: PoopRecordDTO) => ApiService.fromDTO(dto)),
      total: response.data.total || 0
    };
  }

  // æœç´¢è®°å½•
  static async searchRecords(
    color?: string,
    mood?: string,
    startTime?: string,
    endTime?: string,
    page: number = 1,
    size: number = 10
  ): Promise<GeneratedTypeLiteralInterface_4> {
    let url = `${ApiService.BASE_URL}/search?page=${page}&size=${size}`;

    // åœ¨äº‘ç«¯æ¨¡å¼ä¸‹æ·»åŠ userIdå‚æ•°
    const currentUser = UserManager.getCurrentUser();
    if (currentUser) {
      url += `&userId=${encodeURIComponent(currentUser.id)}`;
    }

    if (color) {
      url += `&color=${encodeURIComponent(color)}`;
    }
    if (mood) {
      url += `&mood=${encodeURIComponent(mood)}`;
    }
    if (startTime) {
      url += `&startTime=${encodeURIComponent(startTime)}`;
    }
    if (endTime) {
      url += `&endTime=${encodeURIComponent(endTime)}`;
    }

    const response = await ApiService.request<PageResponse<PoopRecordDTO>>(url, http.RequestMethod.GET);

    // æ·»åŠ ç©ºå€¼æ£€æŸ¥
    if (!response.data || !response.data.records) {
      Logger.error('API', 'APIå“åº”æ•°æ®ä¸ºç©ºæˆ–ç¼ºå°‘recordså­—æ®µ');
      return {
        records: [],
        total: 0
      };
    }

    return {
      records: response.data.records.map((dto: PoopRecordDTO) => ApiService.fromDTO(dto)),
      total: response.data.total || 0
    };
  }

  // è·å–æœ€è¿‘è®°å½•
  static async getRecentRecords(limit: number = 10): Promise<PoopRecord[]> {
    let url = `${ApiService.BASE_URL}/recent?limit=${limit}`;
    
    // åœ¨äº‘ç«¯æ¨¡å¼ä¸‹æ·»åŠ userIdå‚æ•°
    const currentUser = UserManager.getCurrentUser();
    if (currentUser) {
      url += `&userId=${encodeURIComponent(currentUser.id)}`;
    }
    const response = await ApiService.request<PoopRecordDTO[]>(url, http.RequestMethod.GET);
    
    // æ·»åŠ ç©ºå€¼æ£€æŸ¥
    if (!response.data || !Array.isArray(response.data)) {
      Logger.error('API', 'APIå“åº”æ•°æ®ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯');
      return [];
    }
    
    return response.data.map((dto: PoopRecordDTO) => ApiService.fromDTO(dto));
  }

  // è·å–ä»Šæ—¥è®°å½•
  static async getTodayRecords(): Promise<PoopRecord[]> {
    let url = `${ApiService.BASE_URL}/today`;
    
    // åœ¨äº‘ç«¯æ¨¡å¼ä¸‹æ·»åŠ userIdå‚æ•°
    const currentUser = UserManager.getCurrentUser();
    if (currentUser) {
      url += `?userId=${encodeURIComponent(currentUser.id)}`;
    }
    
    const response = await ApiService.request<PoopRecordDTO[]>(
      url,
      http.RequestMethod.GET
    );
    
    // æ·»åŠ ç©ºå€¼æ£€æŸ¥
    if (!response.data || !Array.isArray(response.data)) {
      Logger.error('API', 'APIå“åº”æ•°æ®ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯');
      return [];
    }
    
    return response.data.map((dto: PoopRecordDTO) => ApiService.fromDTO(dto));
  }

  // ç»Ÿè®¡è®°å½•æ•°é‡
  static async countRecords(
    color?: string,
    mood?: string,
    startTime?: string,
    endTime?: string
  ): Promise<number> {
    let url = `${ApiService.BASE_URL}/stats/count`;
    const params: string[] = [];

    if (color) {
      params.push(`color=${encodeURIComponent(color)}`);
    }
    if (mood) {
      params.push(`mood=${encodeURIComponent(mood)}`);
    }
    if (startTime) {
      params.push(`startTime=${encodeURIComponent(startTime)}`);
    }
    if (endTime) {
      params.push(`endTime=${encodeURIComponent(endTime)}`);
    }

    if (params.length > 0) {
      url += '?' + params.join('&');
    }

    const response = await ApiService.request<number>(url, http.RequestMethod.GET);
    return response.data;
  }
}